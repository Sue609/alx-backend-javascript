  * Skip to main content
  * Skip to search
  * Skip to select language

MDN Web DocsOpen main menu

  * ReferencesReferences
    * Overview / Web Technology

Web technology reference for developers

    * HTML

Structure of content on the web

    * CSS

Code used to describe document style

    * JavaScript

General-purpose scripting language

    * HTTP

Protocol for transmitting web resources

    * Web APIs

Interfaces for building web applications

    * Web Extensions

Developing extensions for web browsers

    * Web Technology

Web technology reference for developers

  * GuidesGuides
    * Overview / MDN Learning Area

Learn web development

    * MDN Learning Area

Learn web development

    * HTML

Learn to structure web content with HTML

    * CSS

Learn to style content using CSS

    * JavaScript

Learn to run scripts in the browser

    * Accessibility

Learn to make the web accessible to all

  * PlusPlus
    * Overview

A customized MDN experience

    * AI Help (beta)

Get real-time assistance and support

    * Updates

All browser compatibility updates at a glance

    * Documentation

Learn how to use MDN Plus

    * FAQ

Frequently asked questions about MDN Plus

  * Blog
  * Play
  * AI Help Beta

Search MDNClear search inputSearch

Theme

  * Log in
  * Sign up for free

  1. References
  2. JavaScript
  3. Reference
  4. Classes

Article Actions

  * English (US)

Filter sidebarClear filter input

## In this article

  * Description
  * Examples
  * Specifications
  * Browser compatibility
  * See also

  1. **JavaScript**
  2. **Tutorials**
  3. Complete beginners
    1. JavaScript basics
    2. JavaScript first steps
    3. JavaScript building blocks
    4. Introducing JavaScript objects
  4. JavaScript Guide
    1. Introduction
    2. Grammar and types
    3. Control flow and error handling
    4. Loops and iteration
    5. Functions
    6. Expressions and operators
    7. Numbers and dates
    8. Text formatting
    9. Regular expressions
    10. Indexed collections
    11. Keyed collections
    12. Working with objects
    13. Using classes
    14. Using promises
    15. JavaScript typed arrays
    16. Iterators and generators
    17. Meta programming
    18. JavaScript modules
  5. Intermediate
    1. Client-side JavaScript frameworks
    2. Client-side web APIs
    3. Language overview
    4. JavaScript data structures
    5. Equality comparisons and sameness
    6. Enumerability and ownership of properties
    7. Closures
  6. Advanced
    1. Inheritance and the prototype chain
    2. Memory Management
    3. Concurrency model and Event Loop
  7. **References**
  8. Built-in objects
    1. Overview
    2. AggregateError
    3. Array
    4. ArrayBuffer
    5. AsyncFunction
    6. AsyncGenerator
    7. AsyncGeneratorFunction
    8. AsyncIterator
    9. Atomics
    10. BigInt
    11. BigInt64Array
    12. BigUint64Array
    13. Boolean
    14. DataView
    15. Date
    16. decodeURI()
    17. decodeURIComponent()
    18. encodeURI()
    19. encodeURIComponent()
    20. Error
    21. escape() Deprecated
    22. eval()
    23. EvalError
    24. FinalizationRegistry
    25. Float32Array
    26. Float64Array
    27. Function
    28. Generator
    29. GeneratorFunction
    30. globalThis
    31. Infinity
    32. Int16Array
    33. Int32Array
    34. Int8Array
    35. InternalError Non-standard
    36. Intl
    37. isFinite()
    38. isNaN()
    39. Iterator
    40. JSON
    41. Map
    42. Math
    43. NaN
    44. Number
    45. Object
    46. parseFloat()
    47. parseInt()
    48. Promise
    49. Proxy
    50. RangeError
    51. ReferenceError
    52. Reflect
    53. RegExp
    54. Set
    55. SharedArrayBuffer
    56. String
    57. Symbol
    58. SyntaxError
    59. TypedArray
    60. TypeError
    61. Uint16Array
    62. Uint32Array
    63. Uint8Array
    64. Uint8ClampedArray
    65. undefined
    66. unescape() Deprecated
    67. URIError
    68. WeakMap
    69. WeakRef
    70. WeakSet
  9. Expressions & operators
    1. Overview
    2. Addition (+)
    3. Addition assignment (+=)
    4. Assignment (=)
    5. async function expression
    6. async function* expression
    7. await
    8. Bitwise AND (&)
    9. Bitwise AND assignment (&=)
    10. Bitwise NOT (~)
    11. Bitwise OR (|)
    12. Bitwise OR assignment (|=)
    13. Bitwise XOR (^)
    14. Bitwise XOR assignment (^=)
    15. class expression
    16. Comma operator (,)
    17. Conditional (ternary) operator
    18. Decrement (--)
    19. delete
    20. Destructuring assignment
    21. Division (/)
    22. Division assignment (/=)
    23. Equality (==)
    24. Exponentiation (**)
    25. Exponentiation assignment (**=)
    26. function expression
    27. function* expression
    28. Greater than (>)
    29. Greater than or equal (>=)
    30. Grouping operator ( )
    31. import.meta
    32. import()
    33. in
    34. Increment (++)
    35. Inequality (!=)
    36. instanceof
    37. Left shift (<<)
    38. Left shift assignment (<<=)
    39. Less than (<)
    40. Less than or equal (<=)
    41. Logical AND (&&)
    42. Logical AND assignment (&&=)
    43. Logical NOT (!)
    44. Logical OR (||)
    45. Logical OR assignment (||=)
    46. Multiplication (*)
    47. Multiplication assignment (*=)
    48. new
    49. new.target
    50. null
    51. Nullish coalescing assignment (??=)
    52. Nullish coalescing operator (??)
    53. Object initializer
    54. Operator precedence
    55. Optional chaining (?.)
    56. Property accessors
    57. Remainder (%)
    58. Remainder assignment (%=)
    59. Right shift (>>)
    60. Right shift assignment (>>=)
    61. Spread syntax (...)
    62. Strict equality (===)
    63. Strict inequality (!==)
    64. Subtraction (-)
    65. Subtraction assignment (-=)
    66. super
    67. this
    68. typeof
    69. Unary negation (-)
    70. Unary plus (+)
    71. Unsigned right shift (>>>)
    72. Unsigned right shift assignment (>>>=)
    73. void operator
    74. yield
    75. yield*
  10. Statements & declarations
    1. Overview
    2. async function
    3. async function*
    4. Block statement
    5. break
    6. class
    7. const
    8. continue
    9. debugger
    10. do...while
    11. Empty statement
    12. export
    13. Expression statement
    14. for
    15. for await...of
    16. for...in
    17. for...of
    18. function
    19. function*
    20. if...else
    21. import
    22. Labeled statement
    23. let
    24. return
    25. switch
    26. throw
    27. try...catch
    28. var
    29. while
    30. with Deprecated
  11. Functions
    1. Overview
    2. Arrow function expressions
    3. Default parameters
    4. get
    5. Method definitions
    6. Rest parameters
    7. set
    8. The arguments object
  12. Classes
    1. _Overview_
    2. constructor
    3. extends
    4. Private properties
    5. Public class fields
    6. static
    7. Static initialization blocks
  13. Regular expressions
    1. Overview
    2. Backreference: \1, \2
    3. Capturing group: (...)
    4. Character class escape: \d, \D, \w, \W, \s, \S
    5. Character class: [...], [^...]
    6. Character escape: \n, \u{...}
    7. Disjunction: |
    8. Input boundary assertion: ^, $
    9. Literal character: a, b
    10. Lookahead assertion: (?=...), (?!...)
    11. Lookbehind assertion: (?<=...), (?<!...)
    12. Named backreference: \k<name>
    13. Named capturing group: (?<name>...)
    14. Non-capturing group: (?:...)
    15. Quantifier: *, +, ?, {n}, {n,}, {n,m}
    16. Unicode character class escape: \p{...}, \P{...}
    17. Wildcard: .
    18. Word boundary assertion: \b, \B
  14. Errors
    1. Overview
    2. Error: Permission denied to access property "x"
    3. InternalError: too much recursion
    4. RangeError: argument is not a valid code point
    5. RangeError: BigInt division by zero
    6. RangeError: BigInt negative exponent
    7. RangeError: invalid array length
    8. RangeError: invalid date
    9. RangeError: precision is out of range
    10. RangeError: radix must be an integer
    11. RangeError: repeat count must be less than infinity
    12. RangeError: repeat count must be non-negative
    13. RangeError: x can't be converted to BigInt because it isn't an integer
    14. ReferenceError: "x" is not defined
    15. ReferenceError: assignment to undeclared variable "x"
    16. ReferenceError: can't access lexical declaration 'X' before initialization
    17. ReferenceError: deprecated caller or arguments usage
    18. ReferenceError: reference to undefined property "x"
    19. SyntaxError: "0"-prefixed octal literals and octal escape seq. are deprecated
    20. SyntaxError: "use strict" not allowed in function with non-simple parameters
    21. SyntaxError: "x" is a reserved identifier
    22. SyntaxError: a declaration in the head of a for-of loop can't have an initializer
    23. SyntaxError: applying the 'delete' operator to an unqualified name is deprecated
    24. SyntaxError: await is only valid in async functions, async generators and modules
    25. SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions
    26. SyntaxError: continue must be inside loop
    27. SyntaxError: for-in loop head declarations may not have initializers
    28. SyntaxError: function statement requires a name
    29. SyntaxError: getter and setter for private name #x should either be both static or non-static
    30. SyntaxError: identifier starts immediately after numeric literal
    31. SyntaxError: illegal character
    32. SyntaxError: invalid assignment left-hand side
    33. SyntaxError: invalid BigInt syntax
    34. SyntaxError: invalid regular expression flag "x"
    35. SyntaxError: JSON.parse: bad parsing
    36. SyntaxError: label not found
    37. SyntaxError: missing ; before statement
    38. SyntaxError: missing : after property id
    39. SyntaxError: missing ) after argument list
    40. SyntaxError: missing ) after condition
    41. SyntaxError: missing ] after element list
    42. SyntaxError: missing } after function body
    43. SyntaxError: missing } after property list
    44. SyntaxError: missing = in const declaration
    45. SyntaxError: missing formal parameter
    46. SyntaxError: missing name after . operator
    47. SyntaxError: missing variable name
    48. SyntaxError: redeclaration of formal parameter "x"
    49. SyntaxError: return not in function
    50. SyntaxError: test for equality (==) mistyped as assignment (=)?
    51. SyntaxError: Unexpected '#' used outside of class body
    52. SyntaxError: Unexpected token
    53. SyntaxError: unlabeled break must be inside loop or switch
    54. SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**'
    55. SyntaxError: unterminated string literal
    56. SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead
    57. TypeError: 'x' is not iterable
    58. TypeError: "x" has no properties
    59. TypeError: "x" is (not) "y"
    60. TypeError: "x" is not a constructor
    61. TypeError: "x" is not a function
    62. TypeError: "x" is not a non-null object
    63. TypeError: "x" is read-only
    64. TypeError: can't assign to property "x" on "y": not an object
    65. TypeError: can't convert BigInt to number
    66. TypeError: can't convert x to BigInt
    67. TypeError: can't define property "x": "obj" is not extensible
    68. TypeError: can't delete non-configurable array element
    69. TypeError: can't redefine non-configurable property "x"
    70. TypeError: cannot use 'in' operator to search for 'x' in 'y'
    71. TypeError: cyclic object value
    72. TypeError: invalid 'instanceof' operand 'x'
    73. TypeError: invalid Array.prototype.sort argument
    74. TypeError: invalid assignment to const "x"
    75. TypeError: More arguments needed
    76. TypeError: property "x" is non-configurable and can't be deleted
    77. TypeError: Reduce of empty array with no initial value
    78. TypeError: setting getter-only property "x"
    79. TypeError: X.prototype.y called on incompatible type
    80. URIError: malformed URI sequence
    81. Warning: -file- is being assigned a //# sourceMappingURL, but already has one
    82. Warning: unreachable code after return statement
  15. Misc
    1. JavaScript technologies overview
    2. Lexical grammar
    3. Iteration protocols
    4. Strict mode
    5. Template literals
    6. Trailing commas
    7. Deprecated features

## In this article

  * Description
  * Examples
  * Specifications
  * Browser compatibility
  * See also

# Classes

Classes are a template for creating objects. They encapsulate data with code
to work on that data. Classes in JS are built on prototypes but also have some
syntax and semantics that are unique to classes.

For more examples and explanations, see the Using classes guide.

## Description

### Defining classes

Classes are in fact "special functions", and just as you can define function
expressions and function declarations, a class can be defined in two ways: a
class expression or a class declaration.

js

    
    
    // Declaration
    class Rectangle {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    }
    
    // Expression; the class is anonymous but assigned to a variable
    const Rectangle = class {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    };
    
    // Expression; the class has its own name
    const Rectangle = class Rectangle2 {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    };
    

Like function expressions, class expressions may be anonymous, or have a name
that's different from the variable that it's assigned to. However, unlike
function declarations, class declarations have the same temporal dead zone
restrictions as `let` or `const` and behave as if they are not hoisted.

### Class body

The body of a class is the part that is in curly braces `{}`. This is where
you define class members, such as methods or constructor.

The body of a class is executed in strict mode even without the `"use strict"`
directive.

A class element can be characterized by three aspects:

  * Kind: Getter, setter, method, or field
  * Location: Static or instance
  * Visibility: Public or private

Together, they add up to 16 possible combinations. To divide the reference
more logically and avoid overlapping content, the different elements are
introduced in detail in different pages:

Method definitions

    

Public instance method

getter

    

Public instance getter

setter

    

Public instance setter

Public class fields

    

Public instance field

`static`

    

Public static method, getter, setter, and field

Private properties

    

Everything that's private

**Note:** Private features have the restriction that all property names
declared in the same class must be unique. All other public properties do not
have this restriction — you can have multiple public properties with the same
name, and the last one overwrites the others. This is the same behavior as in
object initializers.

In addition, there are two special class element syntaxes: `constructor` and
static initialization blocks, with their own references.

#### Constructor

The `constructor` method is a special method for creating and initializing an
object created with a class. There can only be one special method with the
name "constructor" in a class — a `SyntaxError` is thrown if the class
contains more than one occurrence of a `constructor` method.

A constructor can use the `super` keyword to call the constructor of the super
class.

You can create instance properties inside the constructor:

js

    
    
    class Rectangle {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    }
    

Alternatively, if your instance properties' values do not depend on the
constructor's arguments, you can define them as class fields.

#### Static initialization blocks

Static initialization blocks allow flexible initialization of static
properties, including the evaluation of statements during initialization,
while granting access to the private scope.

Multiple static blocks can be declared, and these can be interleaved with the
declaration of static fields and methods (all static items are evaluated in
declaration order).

#### Methods

Methods are defined on the prototype of each class instance and are shared by
all instances. Methods can be plain functions, async functions, generator
functions, or async generator functions. For more information, see method
definitions.

js

    
    
    class Rectangle {
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
      // Getter
      get area() {
        return this.calcArea();
      }
      // Method
      calcArea() {
        return this.height * this.width;
      }
      *getSides() {
        yield this.height;
        yield this.width;
        yield this.height;
        yield this.width;
      }
    }
    
    const square = new Rectangle(10, 10);
    
    console.log(square.area); // 100
    console.log([...square.getSides()]); // [10, 10, 10, 10]
    

#### Static methods and fields

The `static` keyword defines a static method or field for a class. Static
properties (fields and methods) are defined on the class itself instead of
each instance. Static methods are often used to create utility functions for
an application, whereas static fields are useful for caches, fixed-
configuration, or any other data that doesn't need to be replicated across
instances.

js

    
    
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    
      static displayName = "Point";
      static distance(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
    
        return Math.hypot(dx, dy);
      }
    }
    
    const p1 = new Point(5, 5);
    const p2 = new Point(10, 10);
    p1.displayName; // undefined
    p1.distance; // undefined
    p2.displayName; // undefined
    p2.distance; // undefined
    
    console.log(Point.displayName); // "Point"
    console.log(Point.distance(p1, p2)); // 7.0710678118654755
    

#### Field declarations

With the class field declaration syntax, the constructor example can be
written as:

js

    
    
    class Rectangle {
      height = 0;
      width;
      constructor(height, width) {
        this.height = height;
        this.width = width;
      }
    }
    

Class fields are similar to object properties, not variables, so we don't use
keywords such as `const` to declare them. In JavaScript, private features use
a special identifier syntax, so modifier keywords like `public` and `private`
should not be used either.

As seen above, the fields can be declared with or without a default value.
Fields without default values default to `undefined`. By declaring fields up-
front, class definitions become more self-documenting, and the fields are
always present, which help with optimizations.

See public class fields for more information.

#### Private properties

Using private fields, the definition can be refined as below.

js

    
    
    class Rectangle {
      #height = 0;
      #width;
      constructor(height, width) {
        this.#height = height;
        this.#width = width;
      }
    }
    

It's an error to reference private fields from outside of the class; they can
only be read or written within the class body. By defining things that are not
visible outside of the class, you ensure that your classes' users can't depend
on internals, which may change from version to version.

Private fields can only be declared up-front in a field declaration. They
cannot be created later through assigning to them, the way that normal
properties can.

For more information, see private properties.

### Inheritance

The `extends` keyword is used in _class declarations_ or _class expressions_
to create a class as a child of another constructor (either a class or a
function).

js

    
    
    class Animal {
      constructor(name) {
        this.name = name;
      }
    
      speak() {
        console.log(`${this.name} makes a noise.`);
      }
    }
    
    class Dog extends Animal {
      constructor(name) {
        super(name); // call the super class constructor and pass in the name parameter
      }
    
      speak() {
        console.log(`${this.name} barks.`);
      }
    }
    
    const d = new Dog("Mitzie");
    d.speak(); // Mitzie barks.
    

If there is a constructor present in the subclass, it needs to first call
`super()` before using `this`. The `super` keyword can also be used to call
corresponding methods of super class.

js

    
    
    class Cat {
      constructor(name) {
        this.name = name;
      }
    
      speak() {
        console.log(`${this.name} makes a noise.`);
      }
    }
    
    class Lion extends Cat {
      speak() {
        super.speak();
        console.log(`${this.name} roars.`);
      }
    }
    
    const l = new Lion("Fuzzy");
    l.speak();
    // Fuzzy makes a noise.
    // Fuzzy roars.
    

### Evaluation order

When a `class` declaration or `class` expression is evaluated, its various
components are evaluated in the following order:

  1. The `extends` clause, if present, is first evaluated. It must evaluate to a valid constructor function or `null`, or a `TypeError` is thrown.
  2. The `constructor` method is extracted, substituted with a default implementation if `constructor` is not present. However, because the `constructor` definition is only a method definition, this step is not observable.
  3. The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the `this` value set to the `this` value surrounding the class (not the class itself). None of the property values are evaluated yet.
  4. Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the `prototype` property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable.
  5. The class is now initialized with the prototype specified by `extends` and implementation specified by `constructor`. For all steps above, if an evaluated expression tries to access the name of the class, a `ReferenceError` is thrown because the class is not initialized yet.
  6. The class elements' values are evaluated in the order of declaration: 
    * For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the `super()` call returns (for derived classes).
    * For each static field (public or private), its initializer is evaluated with `this` set to the class itself, and the property is created on the class.
    * Static initialization blocks are evaluated with `this` set to the class itself.
  7. The class is now fully initialized and can be used as a constructor function.

For how instances are created, see the `constructor` reference.

## Examples

### Binding this with instance and static methods

When a static or instance method is called without a value for `this`, such as
by assigning the method to a variable and then calling it, the `this` value
will be `undefined` inside the method. This behavior is the same even if the
`"use strict"` directive isn't present, because code within the `class` body
is always executed in strict mode.

js

    
    
    class Animal {
      speak() {
        return this;
      }
      static eat() {
        return this;
      }
    }
    
    const obj = new Animal();
    obj.speak(); // the Animal object
    const speak = obj.speak;
    speak(); // undefined
    
    Animal.eat(); // class Animal
    const eat = Animal.eat;
    eat(); // undefined
    

If we rewrite the above using traditional function-based syntax in non–strict
mode, then `this` method calls are automatically bound to `globalThis`. In
strict mode, the value of `this` remains as `undefined`.

js

    
    
    function Animal() {}
    
    Animal.prototype.speak = function () {
      return this;
    };
    
    Animal.eat = function () {
      return this;
    };
    
    const obj = new Animal();
    const speak = obj.speak;
    speak(); // global object (in non–strict mode)
    
    const eat = Animal.eat;
    eat(); // global object (in non-strict mode)
    

## Specifications

Specification  
---  
ECMAScript Language Specification  
# sec-class-definitions  
  
## Browser compatibility

BCD tables only load in the browser with JavaScript enabled. Enable JavaScript
to view data.

## See also

  * Using classes guide
  * `class`
  * `class` expression
  * Functions
  * ES6 In Depth: Classes on hacks.mozilla.org (2015)

### Found a content problem with this page?

  * Edit the page on GitHub.
  * Report the content issue.
  * View the source on GitHub.

Want to get more involved? Learn how to contribute.

This page was last modified on Nov 8, 2023 by MDN contributors.

MDN logo

Your blueprint for a better internet.

  * MDN on Mastodon
  * MDN on Twitter
  * MDN on GitHub
  * MDN Blog RSS Feed

## MDN

  * About
  * Blog
  * Careers
  * Advertise with us

## Support

  * Product help
  * Report an issue

## Our communities

  * MDN Community
  * MDN Forum
  * MDN Chat

## Developers

  * Web Technologies
  * Learn Web Development
  * MDN Plus
  * Hacks Blog

Mozilla logo

  * Website Privacy Notice
  * Cookies
  * Legal
  * Community Participation Guidelines

Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation.  
Portions of this content are ©1998–2023 by individual mozilla.org
contributors. Content available under a Creative Commons license.

  *[
  Deprecated

]: Deprecated. Not for use in new websites.

  *[
    Non-standard
]: Non-standard. Check cross-browser support before using.

